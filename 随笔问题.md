[toc]

### 问题 ：makefile 中.bulid makefile .mk 这三种文件有什么区别吗？

在使用 `make` 工具时，`makefile.build`、`makefile` 和 `.mk` 这三种文件名有一些区别，但主要在于命名惯例和使用习惯方面，而不在于 `make` 工具本身的功能上。

1. **makefile**:
   
   - 这是默认的 `make` 文件名。如果你在命令行中仅输入 `make` 而不指定任何文件，`make` 会自动查找名为 `makefile` 或 `Makefile` 的文件并执行其中的规则。
- 由于这是默认文件名，所以这是最常见的命名方式。
  
2. **makefile.build**:
   - 这不是 `make` 的默认文件名，需要通过指定 `-f` 选项来使用。例如，`make -f makefile.build`。
   - 这种命名通常用于区分不同的构建文件，比如在同一个项目中有多个构建文件时，可以通过不同的后缀来区分其用途（例如，特定的构建配置或步骤）。

3. **.mk**:
   
   - 这是另一种常见的命名方式，特别是在更复杂的项目或构建系统中。这种文件通常被包含在主 `makefile` 中，而不是直接由 `make` 命令执行。
   - 例如，一个项目可能有一个主 `makefile` 文件，其中包含了多个 `.mk` 文件，这些文件可能包含特定的规则或变量定义：
     ```makefile
     include config.mk
     include rules.mk
     ```

总结：
- `makefile` 是 `make` 的默认文件名，最常见。
- `makefile.build` 等带有后缀的文件需要通过 `make -f` 来指定，通常用于区分不同的构建配置或步骤。
- `.mk` 文件常用于被主 `makefile` 包含，帮助组织和管理复杂的构建系统。

这些命名差异主要是基于项目的组织结构和开发者的习惯，而不是 `make` 工具本身的功能差异。





`.build` 文件需要用 `make -f` 来指定的原因是 `make` 工具默认只识别特定名称的文件作为其构建脚本，即 `makefile` 或 `Makefile`。如果构建脚本的名称不同于这两个默认名称，`make` 工具就需要明确地告知使用哪个文件。这是通过 `-f` 选项来实现的。

具体来说，`make` 在执行时会自动查找当前目录下是否存在名为 `makefile` 或 `Makefile` 的文件。如果找不到这两个文件名之一，`make` 会报错说找不到构建文件。在这种情况下，或者如果你有多个构建文件且希望使用一个非默认名称的构建文件，你需要使用 `-f` 选项来指定文件名。例如：

```sh
make -f makefile.build
```

这是为了提供灵活性，让开发者能够根据项目需求创建多个不同的构建文件，并通过显式指定来选择要使用的构建脚本。

以下是一些使用场景和原因：

1. **多配置构建**：
   - 一个项目可能有多个配置，比如调试和发布配置，每个配置可以有独立的构建文件。
   - `make -f makefile.debug` 和 `make -f makefile.release` 可以分别执行不同的构建配置。

2. **模块化构建**：
   - 大型项目可能会将构建规则分割到多个文件中，每个文件专注于项目的某个部分或模块。
   - 例如，可以有 `makefile.core`、`makefile.gui` 等，然后通过 `make -f` 来选择构建哪个部分。

3. **特殊构建任务**：
   - 某些构建任务可能需要特定的构建脚本，例如用于生成文档或运行测试。
   - `make -f makefile.docs` 可以专门用于生成项目文档，而 `make -f makefile.tests` 用于运行测试。

通过使用 `-f` 选项指定非默认的构建文件名称，`make` 工具可以更灵活地处理各种构建场景，满足不同项目和开发流程的需求。



### makefile $(if ) 函数

`$(if)` 函数是 GNU `make` 提供的一个条件函数，用于在 `makefile` 中执行简单的条件判断。它的基本语法如下：

```makefile
$(if condition,then-part[,else-part])
```

- `condition`: 这是一个条件表达式。如果这个表达式的值不为空字符串，则被认为是真。
- `then-part`: 当 `condition` 为真时，返回 `then-part` 的值。
- `else-part`（可选）：当 `condition` 为假时，返回 `else-part` 的值。如果省略 `else-part`，则在条件为假时返回空字符串。

*  示例

假设你有一个变量 `DEBUG`，用于控制是否进行调试构建。可以使用 `$(if)` 来决定编译选项：

```makefile
DEBUG := 1

CFLAGS := $(if $(DEBUG),-g,-O2)
```

在这个例子中，如果 `DEBUG` 不为空（即，条件为真），`CFLAGS` 将被设置为 `-g`（启用调试信息）。否则，`CFLAGS` 将被设置为 `-O2`（优化等级 2）。

* 更复杂的例子

你可以嵌套使用 `$(if)` 函数，创建更复杂的条件逻辑：

```makefile
VAR1 := foo
VAR2 := bar

RESULT := $(if $(VAR1),$(if $(VAR2),both non-empty,$(VAR1) non-empty),VAR1 empty)

# 如果 VAR1 和 VAR2 都不为空，则 RESULT 为 "both non-empty"
# 如果 VAR1 不为空但 VAR2 为空，则 RESULT 为 "foo non-empty"
# 如果 VAR1 为空，则 RESULT 为 "VAR1 empty"
```

* 示例：目标文件的选择

假设你有两个不同版本的目标文件，你可以使用 `$(if)` 根据一个变量来选择其中一个：

```makefile
VERSION := 1

OBJ_FILES := $(if $(VERSION),version1.o,version2.o)

all: $(OBJ_FILES)
	$(CC) -o my_program $(OBJ_FILES)
```

在这个例子中，如果 `VERSION` 不为空，则 `OBJ_FILES` 将被设置为 `version1.o`；否则，设置为 `version2.o`。

* 使用环境变量

你也可以结合环境变量来使用 `$(if)` 函数。例如：

```makefile
INSTALL_DIR := $(if $(PREFIX),$(PREFIX)/usr/local,/usr/local)

install:
	cp my_program $(INSTALL_DIR)/bin
```

在这个例子中，如果环境变量 `PREFIX` 被设置了，`INSTALL_DIR` 将使用 `PREFIX` 指定的目录；否则，将使用默认目录 `/usr/local`。



#### $(wildcard) 函数

在 GNU `make` 中，`$(wildcard)` 函数用于扩展模式匹配符并返回与模式匹配的文件列表。它在自动化文件查找和管理中非常有用，特别是在处理源文件或其他需要动态查找的文件时。

其基本语法是：

```makefile
$(wildcard pattern)
```

其中，`pattern` 是包含通配符（如 `*`、`?`）的模式字符串。

假设你在当前目录下有以下文件：

```text
main.c
utils.c
main.h
utils.h
readme.txt
```

你可以使用 `$(wildcard)` 来找到所有 `.c` 文件：

```makefile
SRC_FILES := $(wildcard *.c)
```

此时，`SRC_FILES` 将包含 `main.c` 和 `utils.c`。

你还可以将目录名和文件模式结合在变量中使用，例如：

```makefile
SRC_DIR := src
SRC_FILES := $(wildcard $(SRC_DIR)/*.c)
```

假设 `src` 目录下有 `file1.c` 和 `file2.c` 文件，则 `SRC_FILES` 将包含 `src/file1.c` 和 `src/file2.c`。

以下是一些具体的使用示例：

1. 自动生成对象文件列表：
   
   ```makefile
   SRC_FILES := $(wildcard *.c)
   OBJ_FILES := $(patsubst %.c,%.o,$(SRC_FILES))

   all: my_program

   my_program: $(OBJ_FILES)
   	$(CC) -o $@ $^

   %.o: %.c
   	$(CC) -c $< -o $@
   ```

   在这个例子中，`SRC_FILES` 自动包含当前目录下所有的 `.c` 文件，并生成对应的 `.o` 文件列表存储在 `OBJ_FILES` 变量中。

2. 查找特定类型的文件：

   ```makefile
   HEADER_FILES := $(wildcard *.h)
   ```

   `HEADER_FILES` 将包含所有 `.h` 文件。

如果你的项目结构包含子目录，可以使用递归通配符来查找子目录中的文件（GNU make 4.0 及以上版本支持）：

```makefile
SRC_FILES := $(wildcard src/**/*.c)
```

这个命令将查找 `src` 目录及其所有子目录中的 `.c` 文件。

你可以结合 `$(wildcard)` 和 `$(foreach)` 实现更复杂的文件查找逻辑。例如，查找多个目录中的文件：

```makefile
DIRS := src lib tests
SRC_FILES := $(foreach dir,$(DIRS),$(wildcard $(dir)/*.c))
```

这个例子会在 `src`、`lib` 和 `tests` 目录中查找所有的 `.c` 文件，并将它们存储在 `SRC_FILES` 中。

`$(wildcard)` 函数在 `makefile` 中是一个非常强大的工具，能够自动查找匹配特定模式的文件，使得构建过程更加灵活和自动化。通过结合使用变量、模式匹配和其他 `make` 函数，可以实现复杂的文件管理和构建规则。



#### $(patsubst) 函数

`$(patsubst)` 是一个 GNU Make 函数，用于模式替换。它在一组单词中，将符合指定模式的部分替换为另一个字符串。

基本语法：
```makefile
#          匹配规则  替换结果     替换源
$(patsubst pattern,replacement,text)  
```

- `pattern`：模式，使用 `%` 表示通配符。
- `replacement`：替换的字符串，同样可以包含 `%` 以表示与模式中通配符对应的部分。
- `text`：要进行模式替换的文本。

示例：
假设有如下 Makefile 代码：

```makefile
sources = foo.c bar.c baz.c
objects = $(patsubst %.c,%.o,$(sources))
```

在这个例子中：
- `sources` 定义了一组源文件列表。
- `$(patsubst %.c,%.o,$(sources))` 将 `sources` 列表中每个以 `.c` 结尾的文件替换成以 `.o` 结尾的文件。

结果：

- `objects` 将包含 `foo.o bar.o baz.o`。







#### $< 的用法举例

在 Makefile 中，`$<` 是一个自动变量，用于表示第一个依赖文件。它通常用于规则的配方（recipe）中，以便引用目标文件的第一个依赖文件。

下面是一个简单的例子，展示了如何使用 `$<`：

```makefile
# 定义编译器和编译选项
CC = gcc
CFLAGS = -Wall -g

# 定义目标文件
TARGET = myprogram

# 定义源文件和对象文件
SRCS = main.c utils.c
OBJS = $(SRCS:.c=.o)

# 默认目标
all: $(TARGET)

# 链接目标文件
$(TARGET): $(OBJS)
    $(CC) $(CFLAGS) -o $@ $^

# 编译源文件到对象文件
%.o: %.c
    $(CC) $(CFLAGS) -c $< -o $@

# 清理生成的文件
clean:
    rm -f $(OBJS) $(TARGET)
```

在这个示例中，`%.o: %.c` 是一个模式规则，表示所有的 `.c` 文件都会被编译成对应的 `.o` 文件。在该规则的配方中，`$<` 用于表示模式匹配的第一个依赖文件，即当前正在被编译的 `.c` 文件。

例如，当 `main.c` 需要被编译时，`$<` 的值就是 `main.c`，对应的命令行就是：

```sh
gcc -Wall -g -c main.c -o main.o
```

同样地，当 `utils.c` 需要被编译时，`$<` 的值就是 `utils.c`，对应的命令行就是：

```sh
gcc -Wall -g -c utils.c -o utils.o
```

通过使用 `$<`，可以使 Makefile 更加简洁和灵活，因为它自动引用了当前的源文件，而无需手动指定。





#### Makefile 什么时候会执行结束

在Makefile中，行的结束由换行符（\n）或分号（;）来表示。Make会按行读取Makefile，并执行每一行中的命令，直到遇到一个新的规则或者文件结束。

如果一行太长而无法在一行中显示，可以使用反斜杠（\）将其分隔成多行。Make会将多行拼接在一起视为单独的一行。例如：

```makefile
target: dependency1 dependency2 \
         dependency3
    command1
    command2
```

这个规则定义了一个名为target的目标，它依赖于dependency1、dependency2和dependency3。当这个目标被执行时，会依次执行command1和command2。Make会将命令1和命令2视为同一行的一部分，直到遇到一个新的规则或文件结束。

因此，Make会根据换行符、分号以及反斜杠来确定命令的结束，而不是根据特定的行结束符。

